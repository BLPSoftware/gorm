package gorm

import (
	"fmt"
	"reflect"
	"strings"
	"time"

	_ "github.com/nakagami/firebirdsql"
)

var dialectname string = "firebirdsql"

type firebirddialect struct {
	commonDialect
}

func init() {
	RegisterDialect(dialectname, &firebirddialect{})
}

// GetName get dialect's name
func (firebirddialect) GetName() string {
	return dialectname
}

// SetDB set db for dialect
// func SetDB(db SQLCommon)										- using the common dialects implementation

// TODO test
// BindVar return the placeholder for actual values in SQL statements, in many dbs it is "?", Postgres using $1
func BindVar(i int) string {
	return "?"
}

// Quote quotes field name to avoid SQL parsing exceptions by using a reserved word as a field name
// func Quote(key string) string 								- using common dialect, as quoting is done by double quotes

// DataTypeOf return data's sql type
func (f *firebirddialect) DataTypeOf(field *StructField) string {
	var dataValue, sqlType, size, additionalType = ParseFieldStructForDialect(field, f)

	if sqlType == "" {
		switch dataValue.Kind() {
		case reflect.Bool:
			sqlType = "SMALLINT"
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uintptr:
			if f.fieldCanAutoIncrement(field) {
				sqlType = "INTEGER GENERATED BY DEFAULT AS IDENTITY"
			} else {
				sqlType = "INTEGER"
			}
		case reflect.Int64, reflect.Uint64:
			if f.fieldCanAutoIncrement(field) {
				sqlType = "BIGINT GENERATED BY DEFAULT AS IDENTITY"
			} else {
				sqlType = "BIGINT"
			}
		case reflect.Float32, reflect.Float64:
			sqlType = "FLOAT"
		case reflect.String:
			if size > 0 && size < 65532 {
				sqlType = fmt.Sprintf("VARCHAR(%d)", size)
			} else {
				sqlType = "VARCHAR(65532)"
			}
		case reflect.Struct:
			if _, ok := dataValue.Interface().(time.Time); ok {
				sqlType = "TIMESTAMP"
			}
		default:
			if _, ok := dataValue.Interface().([]byte); ok {
				if size > 0 && size < 65532 {
					sqlType = fmt.Sprintf("BINARY(%d)", size)
				} else {
					sqlType = "BINARY(65532)"
				}
			}
		}
	}

	if sqlType == "" {
		panic(fmt.Sprintf("invalid sql type %s (%s) for commonDialect", dataValue.Type().Name(), dataValue.Kind().String()))
	}

	if strings.TrimSpace(additionalType) == "" {
		return sqlType
	}
	return fmt.Sprintf("%v %v", sqlType, additionalType)
}

// TODO test
// HasIndex check has index or not
func (f *firebirddialect) HasIndex(tableName string, indexName string) bool {
	var count int
	f.db.QueryRow("SELECT COUNT(*) FROM RDB$INDICES WHERE RDB$RELATION_NAME = ? AND RDB$INDEX_NAME = ?;", tableName, indexName).Scan(&count)
	return count > 0
}

//TODO test
// HasForeignKey check has foreign key or not
func (f *firebirddialect) HasForeignKey(tableName string, foreignKeyName string) bool {
	var count int
	f.db.QueryRow("select COUNT(ix.rdb$index_name) as index_name, sg.rdb$field_name as field_name from rdb$indices ix left join rdb$index_segments sg on ix.rdb$index_name = sg.rdb$index_name left join rdb$relation_constraints rc on rc.rdb$index_name = ix.rdb$index_name where rc.rdb$constraint_type = 'FOREIGN KEY' and rc.rdb$relation_name = ? and rc.rdb$contrained_name = ?", tableName, foreignKeyName)
	return count > 0
}

// RemoveIndex remove index
// RemoveIndex(tableName string, indexName string) error		- using the common dialects implementation

// TODO test
// HasTable check has table or not
func (f *firebirddialect) HasTable(tableName string) bool {
	var count int
	f.db.QueryRow("SELECT COUNT(*) FROM RDB$RELATION_FIELDS RF WHERE RF.RDB$RELATION_NAME = ?;", tableName).Scan(&count)
	return count > 0
}

// TODO test
// HasColumn check has column or not
func (f *firebirddialect) HasColumn(tableName string, columnName string) bool {
	var count int
	f.db.QueryRow("SELECT COUNT(*) FROM RDB$RELATION_FIELDS RF WHERE RF.RDB$RELATION_NAME = ? AND RF.RDB$FIELD_NAME = ?;", tableName, columnName).Scan(&count)
	return count > 0
}

// ModifyColumn modify column's type
// ModifyColumn(tableName string, columnName string, typ string) error 						- uses the standard common implemention

// LimitAndOffsetSQL return generated SQL with Limit and Offset, as mssql has special case
func (f *firebirddialect) LimitAndOffsetSQL(limit, offset interface{}) (sql string, err error) {
	// sql += " ROWS %s TO %s"
	if limit != nil {
		if parsedLimit, err := f.parseInt(limit); err != nil {
			return "", err
		} else if parsedLimit >= 0 {
			sql += fmt.Sprintf(" ROWS %d", parsedLimit)
		}
	}
	if offset != nil {
		if parsedOffset, err := f.parseInt(offset); err != nil {
			return "", err
		} else if parsedOffset >= 0 {
			sql += fmt.Sprintf(" TO %d", parsedOffset)
		}
	}
	return
}

// SelectFromDummyTable return select values, for most dbs, `SELECT values` just works, mysql needs `SELECT value FROM DUAL`
// SelectFromDummyTable() string															- uses the standard common implementation

// LastInsertIDOutputInterstitial most dbs support LastInsertId, but mssql needs to use `OUTPUT`
// LastInsertIDOutputInterstitial(tableName, columnName string, columns []string) string	- uses the standard common implementation

// LastInsertIdReturningSuffix most dbs support LastInsertId, but postgres needs to use `RETURNING`
// LastInsertIDReturningSuffix(tableName, columnName string) string							- uses the standard common implementation

// DefaultValueStr
// DefaultValueStr() string																	- uses the standard common implementation

// BuildKeyName returns a valid key name (foreign key, index key) for the given table, field and reference
// BuildKeyName(kind, tableName string, fields ...string) string							- uses the standard common implementation

// NormalizeIndexAndColumn returns valid index name and column name depending on each dialect
func (f *firebirddialect) NormalizeIndexAndColumn(indexName, columnName string) (string, string) {
	return indexName, fmt.Sprintf("\"%s\"", columnName)
}

// This function does not exist for firebird
// CurrentDatabase return current database name
func (f *firebirddialect) CurrentDatabase() string {
	return ""
}

/*
type SQLCommon interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Prepare(query string) (*sql.Stmt, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
}

type Dialect interface {

}
*/
